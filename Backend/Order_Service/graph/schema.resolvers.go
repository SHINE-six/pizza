package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"Order_Service/graph/model"
	"Order_Service/internal/kafka"
	"context"
	"log"
	db_struct "pizza/db/struct"
	"strconv"
	"time"

	"gorm.io/gorm"
)

// CreatePizza is the resolver for the createPizza field.
func (r *mutationResolver) CreatePizza(ctx context.Context, baseID string, sizeID string, toppingIds []string, customerID string) (*model.Pizza, error) {
	// Upload to the database
	var dbToppings []db_struct.Topping

	r.DB.Find(&dbToppings, toppingIds)

	// Check if the order exists, if not create a new order
	orderID, err := checkOrderExists(r.DB, customerID)
	if err != nil {
		return nil, err
	}

	// Convert the baseID and sizeID to uint
	baseIDUint, err := strconv.ParseUint(baseID, 10, 64)
	if err != nil {
		return nil, err
	}
	sizeIDUint, err := strconv.ParseUint(sizeID, 10, 64)
	if err != nil {
		return nil, err
	}

	// get the size multiplier, base price and toppings price
	db_size := db_struct.Size{}
	r.DB.First(&db_size, sizeIDUint)
	db_base := db_struct.Base{}
	r.DB.First(&db_base, baseIDUint)

	price := db_size.Multiplier * (db_base.Price + dbToppingsPrice(dbToppings))

	// Create the pizza in the database
	toDBpizza := &db_struct.Pizza{
		OrderID:  uint(orderID),
		BaseID:   uint(baseIDUint),
		Base:     db_base,
		SizeID:   uint(sizeIDUint),
		Size:     db_size,
		Toppings: dbToppings,
		Price:    price,
	}
	r.DB.Create(toDBpizza)
	// update the order total price and add pizza to the order
	var order db_struct.Order
	if err := r.DB.Preload("Pizzas").First(&order, orderID).Error; err != nil {
		log.Println("Error finding order: ", err)
		return nil, err
	}
	if err := r.DB.Model(&order).Association("Pizzas").Append(toDBpizza); err != nil {
		log.Println("Error appending pizza to order: ", err)
		return nil, err
	}
	// Update the order's total price
	if err := r.DB.Model(&order).Update("total_price", gorm.Expr("total_price + ?", price)).Error; err != nil {
		log.Println("Error updating order total price: ", err)
		return nil, err
	}

	r.DB.First(&order, orderID)
	pizzas := order.Pizzas
	for _, pizza := range pizzas {
		var base db_struct.Base
		r.DB.First(&base, pizza.BaseID)
		log.Printf("Pizza: %v  %v\n", base.Name, pizza.ID)
	}

	kafka.ProduceOrderCreatedEvent(ctx, "", "", toDBpizza)

	// find the base, size and toppings
	var base model.Base
	var size model.Size
	var toppings []model.Topping

	r.DB.First(&base, baseID)
	r.DB.First(&size, sizeID)
	for _, toppingID := range toppingIds {
		var topping model.Topping
		toppingIDUint, err := strconv.ParseUint(toppingID, 10, 64)
		if err != nil {
			return nil, err
		}
		r.DB.First(&topping, toppingIDUint)
		toppings = append(toppings, topping)
	}

	price = size.Multiplier * (base.Price + toppingsPrice(toppings))

	pizzaIDString := strconv.FormatUint(uint64(toDBpizza.ID), 10)
	// Create the pizza
	pizza := &model.Pizza{
		ID:        pizzaIDString,
		OrderID:   strconv.FormatUint(uint64(orderID), 10),
		Base:      &base,
		Size:      &size,
		Toppings:  make([]*model.Topping, len(toppings)),
		Price:     price,
		CreatedAt: time.Now().String(),
		UpdatedAt: time.Now().String(),
	}

	// Assign the toppings to the pizza
	for i, topping := range toppings {
		pizza.Toppings[i] = &topping
	}

	return pizza, nil
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, orderID string, status string, deliveryStaffID *string) (*model.Order, error) {
	var order db_struct.Order

	// Convert the orderID to uint
	orderIDUint, err := strconv.ParseUint(orderID, 10, 64)
	if err != nil {
		return nil, err
	}

	// Find the order
	if err := r.DB.First(&order, orderIDUint).Error; err != nil {
		return nil, err
	}

	// Update the order status
	if err := r.DB.Model(&order).Update("status", status).Error; err != nil {
		return nil, err
	}

	// Get the customer email to prepare to produce orderStatusUpdated event
	var customer db_struct.Customer
	r.DB.First(&customer, order.CustomerID)

	// Update the delivery staff ID if it is provided
	if deliveryStaffID != nil {
		deliveryStaffIDUint, err := strconv.ParseUint(*deliveryStaffID, 10, 64)
		if err != nil {
			return nil, err
		}

		if err := r.DB.Model(&order).Update("delivery_staff_id", deliveryStaffIDUint).Error; err != nil {
			log.Println("Error updating delivery staff ID: ", err)
			return nil, err
		}

		// Meaning delivery staff has select the order to deliver
		// Produce the kafka pizzaInDelivering email event
		if status == "delivering" {
			kafka.ProduceOrderDeliveringEvent(customer.Email, customer.Username, *deliveryStaffID, orderID)
		}
	}

	// Convert the order to the model
	r.DB.Preload("Pizzas").First(&order, orderIDUint) // Preload the pizzas for the order
	modelOrder := &model.Order{
		ID:         orderID,
		Customer:   &model.Customer{},
		Pizzas:     make([]*model.Pizza, len(order.Pizzas)),
		Status:     status,
		TotalPrice: order.TotalPrice,
		CreatedAt:  order.CreatedAt.String(),
		UpdatedAt:  order.UpdatedAt.String(),
	}

	// Assign the customer to the order
	r.DB.First(&modelOrder.Customer, order.CustomerID)

	// Assign the pizzas to the order
	for i, pizza := range order.Pizzas {
		r.DB.Preload("Toppings").First(&pizza, pizza.ID) // Preload the toppings for the pizza

		modelOrder.Pizzas[i] = &model.Pizza{
			ID:        strconv.FormatUint(uint64(pizza.ID), 10),
			Base:      &model.Base{},
			Size:      &model.Size{},
			Toppings:  make([]*model.Topping, len(pizza.Toppings)),
			Price:     pizza.Price,
			CreatedAt: pizza.CreatedAt.String(),
			UpdatedAt: pizza.UpdatedAt.String(),
		}

		// Assign the base and size to the pizza
		r.DB.First(&modelOrder.Pizzas[i].Base, pizza.BaseID)
		r.DB.First(&modelOrder.Pizzas[i].Size, pizza.SizeID)

		// Assign the toppings to the pizza
		for j, topping := range pizza.Toppings {
			modelOrder.Pizzas[i].Toppings[j] = &model.Topping{
				ID:    strconv.FormatUint(uint64(topping.ID), 10),
				Name:  topping.Name,
				Price: topping.Price,
			}
		}
	}

	return modelOrder, nil
}

// AllOrders is the resolver for the allOrders field.
func (r *queryResolver) AllOrders(ctx context.Context, status *string, deliveryStaffID *string, customerID *string, orderID *string) ([]*model.Order, error) {
	var orders []db_struct.Order

	// Find all orders with parameters status, delivery staff ID, customer ID or order ID, or if none of them are provided, find all orders
	query := r.DB
	if status != nil {
		query = query.Where("status = ?", *status)
	}
	if deliveryStaffID != nil {
		deliveryStaffIDUint, err := strconv.ParseUint(*deliveryStaffID, 10, 64)
		if err != nil {
			return nil, err
		}
		query = query.Where("delivery_staff_id = ?", deliveryStaffIDUint)
	}
	if customerID != nil {
		customerIDUint, err := strconv.ParseUint(*customerID, 10, 64)
		if err != nil {
			return nil, err
		}
		query = query.Where("customer_id = ?", customerIDUint)
	}
	if orderID != nil {
		orderIDUint, err := strconv.ParseUint(*orderID, 10, 64)
		if err != nil {
			return nil, err
		}
		query = query.Where("id = ?", orderIDUint)
	}

	if err := query.Find(&orders).Error; err != nil {
		log.Println("Error finding orders: ", err)
		return nil, err
	}

	// Convert the orders to the model
	modelOrders := make([]*model.Order, len(orders))
	for i, order := range orders {
		r.DB.Preload("Pizzas").First(&order, order.ID) // Preload the pizzas for the order
		// r.DB.Find(&order.Pizzas, "order_id = ?", order.ID)    // Find the pizzas for the order   //! maybe can removed, since preload already done
		modelOrders[i] = &model.Order{
			ID:            strconv.FormatUint(uint64(order.ID), 10),
			DeliveryStaff: &model.DeliveryStaff{},
			Customer:      &model.Customer{},
			Pizzas:        make([]*model.Pizza, len(order.Pizzas)),
			Status:        order.Status,
			TotalPrice:    order.TotalPrice,
			CreatedAt:     order.CreatedAt.String(),
			UpdatedAt:     order.UpdatedAt.String(),
		}

		// Assign the delivery staff to the order
		r.DB.First(&modelOrders[i].DeliveryStaff, order.DeliveryStaffID)

		// Assign the customer to the order
		r.DB.First(&modelOrders[i].Customer, order.CustomerID)

		// Assign the pizzas to the order
		for j, pizza := range order.Pizzas {
			r.DB.Preload("Toppings").First(&pizza, pizza.ID) // Preload the toppings for the pizza

			modelOrders[i].Pizzas[j] = &model.Pizza{
				ID:        strconv.FormatUint(uint64(pizza.ID), 10),
				Base:      &model.Base{},
				Size:      &model.Size{},
				Toppings:  make([]*model.Topping, len(pizza.Toppings)),
				Price:     pizza.Price,
				CreatedAt: pizza.CreatedAt.String(),
				UpdatedAt: pizza.UpdatedAt.String(),
			}

			// Assign the base and size to the pizza
			r.DB.First(&modelOrders[i].Pizzas[j].Base, pizza.BaseID)
			r.DB.First(&modelOrders[i].Pizzas[j].Size, pizza.SizeID)

			// Assign the toppings to the pizza
			for k, topping := range pizza.Toppings {
				modelOrders[i].Pizzas[j].Toppings[k] = &model.Topping{
					ID:    strconv.FormatUint(uint64(topping.ID), 10),
					Name:  topping.Name,
					Price: topping.Price,
				}
			}
		}
	}

	return modelOrders, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
